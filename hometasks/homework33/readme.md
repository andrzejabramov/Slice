# Описание модуля 7_3.py
### Для создания директории и файлов программно импортируем библиотеку os
### Для демонстрации варманта удаления из строки пунктуации импортиуем библиотеку string

## Создаем класс class WordsFinder
### Атрибут - *file_name (принимаем неограниченное количество имен файлов)
## Методы:
### 1. Создание директории (инкапсулированный): 
```commandline
    def __create_directory(self):
        dir = input('Введите название директории: ')
        try:
            os.mkdir(r'./'+dir)
        except FileExistsError:
            print(f"Директория с именем {dir} уже существует, действия будут производиться в существующей директории")
        return dir
```
Если директории с вводимым пользователем именем нет, то создается, если есть, то получаем уведомление. Возвращается имя директории в любом случае
### 2. Инкапсулированный метод проверки введенного пользователем значения в функцию input:
```commandline
    def __yes_no(self):
        ch = input('Для добавления изменений в существующий файл нажмите аббревиатуру Save - символ S\n'
                   'чтобы оставить только новые данные нажмите символ R\n'
                   'чтобы сохраниить новый файл с другим именем, нажмите аббревиатуру Save As - символы SA\n'
                   'чтобы закрыть файл без сохранения, нажмите аббревиатуру Cancel - символ C\n')
        while True:
            if ch.upper() == 'S' or ch.upper() == 'R' or ch.upper() == 'SA' or ch.upper() == 'C':
                return ch.upper()
            ch = input('Введен неверный символ, повторите ввод: ')
```
Этот метод используется для проверки валидности вводимых пользователем символов для выбора действий записи в файл:
а именно ограничивает варианты набора и при ошибке сообщает об этом, предлагая повторить набор (за это отвечает цикл While True)
При верном вводе символов: проверка на регистр (перевод в верхний), возвращается введенный/е символ/ы в верхнем регистре.
### 3. Инкапсулированный метод __add_text(name_file) позволяет вводить текст в текущий файл 
```commandline
    def __add_text(self, name_file):
        txt = input(f"Введите текст через запятую, например text1, text2, text3 для файла {name_file}: ")
        return txt.replace(', ', ''+'\n')
```
### С помощью функции input() мы вводим текст, который метод возвращает с переносом на след строку, если обнаружена запятая
### 4. Метод create_file создает новый файл, если файл с таим именем отсутствует в директории или предлагшает варианты действий с файлом, если файл с таким именем присутствует в папке  
```commandline
    def create_file(self):
        d = self.__create_directory(); file_list = self.file_name; attr = None
        for fl in file_list:
            try:
                with open(r'./'+d+'/'+fl, 'x', encoding='utf-8') as fn:
                    fn.write(self.__add_text(fl))
            except FileExistsError:
                print(f"Файл с именем {fl} уже есть в директории")
                ch = self.__yes_no()
                if ch == 'C':
                    print(f"Файл {fl} остался без изменений")
                else:
                    if ch == 'S':
                        attr = 'a'
                    elif ch == 'R':
                        attr = 'w'
                    elif ch == 'SA':
                        fl = input('Введите название нового файла: ')
                        attr = 'x'
                    with open(r'./' + d + '/'+ fl, attr, encoding='utf-8') as file:
                        file.write('\n'+self.__add_text(fl)) if ch == 'S' else file.write(self.__add_text(fl)) и переменной, которая будет содержать признак действия с файлом (чтение, добавление, запись) пока задаем значение None
                        
        return ''

```
### Сначала вызываем метод __create_directory(), присваиваем переменной file_list список файлов из атрибута класса и переменной attr, которая будет содержать значение признака работы с файлом (r - чтение, w - запись, a - добавление или х - запись в новый файл) значение None.
### Проходим циклом по списку файлов в аттрибуте класса file_name и проверяем существование файла через исключение (можно применить альтернативный вариант через проверку условия if os.path.exists) 
### Итак, если файла с требуемым именем в папке нет, то введеннный через input() текст записывается в файл (attr = 'x'), если же файл такой есть, управление переходит в блок исключения и предлагается выбрать вариант рпаботы: ввести в input():
### - символ 'c' (cansel) - ничего не делаем, файл не изменяется
### - символ 's' (save) - дозаписываем в файл дополнительно к уже имеющемуцся тексту новый с новой строки
### - символ 'r' (rewrite) - перезаписываем содержимое файла новым тестом, старый удален
### - символы 'sa' (save as) - предлагается выбрать файлу имя и текс записывается в новый файл
### 5. Метод get_all_words(): возвращает согласно заданию словарь с ключами - имена файлов и значениями - списки текста, элементы которого разделены по пробелам  
```commandline
    def get_all_words(self):
        all_words = {}; punkt = [',', '.', '=', '!', '?', ';', ':', ' - ']
        dir = self.__create_directory(); file_list = self.file_name
        for fl in file_list:
            with open(r'./'+dir+'/'+fl, 'r') as fn:
                txt = fn.read()
            for symb in punkt:
                if symb in txt:
                    #txt.translate(str.maketrans('', '', string.punctuation))
                    txt = txt.replace(symb, ' ')
                    txt = txt.replace('\n', ' ')
            txt = txt.lower().split()
            txt = list(txt)
            all_words[fl] = txt
        return all_words
```
### Сначала убираем пунктуацию: по заданию определены знаки пунктуации, которые исключаем, поэтому не был применен метод punctuation библиотеки string, но импорт ее сделан и строка кода с вызовом этого метода присутсвует и закомментирована
### Итак, вначале создаем пустой словарь, список убираемых знаков пунктуации, робочую директорию и список файлов. 
### Проходим циклом по по файлам, каждый из них открываем на чтение с помощью оператора with и записываем текст в переменную. 
### Проверяем: просутствует ли каждый из списка знаков пунктуации в тексте и если да, то заменяем его на пробел, то же самое делаем с '\n' (он не включен в список), переводим все символы текста в нижний регистр по заданию, сохраняем отдельные слова в виде списка и формируем словарь, добавляя в него новые пары в каждом цикле
### Этот словарь возвращавется методом
### 6. Метод find(word) возаращает словарь с ключем - имя файла и значения - текст файла, в котором содержится входной атрибут метода
```commandline
    def find(self, word):
        d = {}; l = list(self.get_all_words().items())
        for tup in l:
            if word in tup[1]:
                d[tup[0]] = tup[1]
        return d
```
### Создаем пустой словарь, перебираем пары из словаря, возвращаемого методом get_all_words() с помощью функции items(), проходим циклом по полученным кортежам, а в них проверяем присутствует ли входной атрбут в списке значений кортежа (по индексу [1]). Если да, то добавляем пару из ключа - название файла под индексом [0] в кортеже и значения под индексом [1].
### Возвращаем словарь на выходе
### 7. Метод count(word) возвращает словарь в ключами - именами файлов и значениями - количество вхождений автрибута, подающегося на вход метода в списке слов (по разделителю - пробелу) в каждом файле 
```commandline
    def count(self, word):
        d = {}; l = list(self.get_all_words().items())
        for tup in l:
            count = 0
            for w in tup[1]:
                if w.find(word) != -1:
                    count += 1
            d[tup[0]] = count
        return d
```
### Задаем пустой словаоь и в переменную сохраняем результат метода count().
### Проходим циклом по элементам полученного из метода get_all_words() c помощью функции items() кортежу.
### Задаем счетчик циклов для подсчета кодичества вхождений входного атрибута в слова в файле
### Если вхождение найдено (if w.find(word) != -1:), то счетчик увеличивается на 1.  
### а в цикле по именам файла формируется итоговая величина вхождений.
### 8. Управляющий блок состоит:
```commandline
wf = WordsFinder('text1.txt', 'text2.txt', 'text3.txt')
print(wf.get_all_words())
print(wf.find('word2'))
print(wf.count('word'))
print(wf.create_file())
```
### - из определения экз класса с передачей ему имен файлов
### - вызовов методов по заданию (get_all_words(), find('word2'), count('word'))
### - а также дополнительныго метода create_file()
