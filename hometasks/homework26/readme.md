# Домашнее задание выполнено Абрамовым Андреем
## 1. Класс User
### _В классе инициализировано три параметра:_
#### nickname - логин
#### password - вводится открытым текстом, но для хранения применятся функция hash
#### age - возраст для определения доступности контента
#### метод user_list добавлен для упаковки параметров в список

```commandline
class User:
    def __init__(self, nickname, password, age=None):
        self.nickname = nickname
        self.password = password
        self.age = age

    def __str__(self) -> str:
        return f"{self.nickname}, {hash(self.password)}, {self.age}"

    def user_list(self) -> list:
        l = [self.nickname, hash(self.password), self.age]
        return list(l)
```
## 2. Класс Video
### _В классе инициализировано 4 парамерта:_
#### title - имя видео
#### duration - продолжительность видео, сек
#### time_now - время, на которое пользователь запускает видео на просмотр, сек.
#### это параметр по умолчанию равен 0 сек и по смыслу не может быть больше duration, поэтому в блоке инициализации происходит проверка и приведение в соответствие. 
#### adult_mode - булевый признак ограничения контента 18+ (если True). По умолчанию False
#### метод Film добавлен для упаковки параметорв в список

```commandline
class Video:
    def __init__(self, title, duration, time_now=0, adult_mode=False):
        self.title = title
        self.duration = duration
        self.time_now = time_now
        self.adult_mode = adult_mode
        if time_now > duration:
            print('Вы ввели время просмотра видео больше его длительности,\n' \
                  'поэтому просмотр будет длиться до окончания фильма')
            self.time_now = duration

    def __str__(self) -> str:
        return f"{self.title}, {self.duration}, {self.time_now}, {self.adult_mode}"

    def film(self):
        l = [self.title, self.duration, self.time_now, self.adult_mode]
        return list(l)
```

# 3. Класс UrTube
## В классе созданы 3 параметра
###  users - статический параметр формата матрица, по умолчанию пустой для хранения списка пользователей (каждый - отдельная строка в виде списка с определенным количеством параметров в виде элементов) 
### videos - статический параметр формата матрица, по умолчанию пустой для хранения списка видео (каждое - отдельная строка в виде списка с определенным количеством параметров в виде элементов)  
### current_user - динамический параметр для хранения логина текущего пользователя

```commandline
class UrTube:
    users = []
    videos = []
    def __init__(self, current_user=None):
        self.current_user = current_user

    def __str__(self):
        return f"{self.users}, {self.videos}, {self.current_user}"

```

## Методы класса
### метод register
```commandline
    def register(self, nickname, password, age):
        u = User(nickname, password, age)
        l = u.user_list()
        if len(UrTube.users) > 0:
             for i in range(len(UrTube.users)):
                  if UrTube.users[i][0] == nickname:
                      return f"Пользователь {nickname} уже существует"
        UrTube.users.append(l)
        self.current_user = nickname
        return f"{nickname}! Поздравляем с регистрацией!"
```
### принимает три параметра: логин, пароль текстом, возраст пользователя
Вызывая класс User, и передавая ему эти три входных параметра, мы получаем список с параметрами. Пароль уже зашифрован функцией hash(). Если список не пустой, то проходим циклом по списку, проверяя, не зарегистрирован ли пользователь, чьи параметры подаются на вход. Если пользователь найден цикл обрывается с уведомлением, что данный пользователь уже существует. Если же список пользователей пустой или пользователь в списке не найден - происходит регистрация пользователя путем добавления в список пользователей.

### метод log_in
```commandline
    def log_in(self, nickname, password):
        u = User(nickname, password)
        l = u.user_list()[:-1]
        for i in range(len(UrTube.users)):
            nick = UrTube.users[i][:-1]
            if nick == l:
                self.current_user = nickname
                return f"Добро, пожаловать, {nickname}!"
        return f"Неверно введен логин {nickname} или пароль"
```
### принимает на вход два параметра: логин и пароль. Вызываем экз класса User, в результате чего получаем список парамеров пользователя с зашифрованным функцией hash() паролем. Методом slice обрезем третий параметр age (для авторизации он не нужен). Проходим по списку пользователей, в каждом цикле прохода вырезаем в списке пользователей третий параметр через метод slice() и сравниваем поступившую на вход пару логин - зашифрованный пароль с парой из списка логин - зашифрованный пароль. Если совпадающая пара найдена, то параметру current_user присваивается имя (логин) пользователя метод возвращает этот параметр, если же не найдена, то возвращаетя соответствующее уведомление.

### метод log_out
```commandline
    def lod_out(self):
        nick = self.current_user
        self.current_user = None
        return f"{nick}, Вы вышли из аккаунта"
```
### не имеет входных параметров. Его задача изменить значение параметра класса UrTube current_user на None, то есть разлогиниться.

### метод add
```commandline
    def add(self, *args):
        for v in args:
            f = Video.film(v)
            if len(UrTube.videos) > 0:
                for i in range(len(UrTube.videos)):
                    if UrTube.videos[i][0] == f[0]:
                        return None
            UrTube.videos.append(f)
        return None
```

### на вход метод принимает гнабор неименованных аргументов, чтобы была возможность одновременного добавления несколько видео. Проходим циклом по аргументам входного параметра и каждый пропускаем через класс Video для получения параметров видео в виде списка. Если фильмотека (плейлист) у нас не пустая, то мы проходим по всем ее элементам и проверяем нет ли добавляемого нами фильма в ней уже. Если нет или до этого было определено, что плейлист пуст, то фильм добавляется (все его параметры). Если же такой фильм уже в плейлисте, то метод возвращает None (ничего не происходит).  

### метод get_videos
```commandline
    def get_videos(self, template):
        l = []
        for temp in range(len(UrTube.videos)):
            name = UrTube.videos[temp][0]
            if template.lower() in name.lower():
                l.append(name)
        return l
```
### метод получает на вход набор букв (шаблон или template), объявляет переменную l по умолчанию пустой список. Циклом проходит по списку фильмов в плейлисте, выбирая наименование фильма в каждом проходе цикла, переводит это имя и шаблон в нижний регистр и проверяет вхождение шаблона в имя фильма. Если набор символов шаблона присутствует в имени фильма, то этот фильм добпавляется в список l, котороый и возвращает метод. 

### метод watch_video
```commandline
        def watch_video(self, name):
        if self.current_user == None:
            return 'Для просмотра видео авторизуйтесь пожалуйста'
        for i in range(len(UrTube.videos)):
            if name == UrTube.videos[i][0]:
                for u in range(len(UrTube.users)):
                    if self.current_user == UrTube.users[u][0]:
                        if UrTube.users[u][2] < 18 and (UrTube.videos[i][3] is True):
                            return 'Вам нет 18 лет, пожалуйста покиньте страницу'
                view = self._dur_video(UrTube.videos[i][2])
                return view
        return f"Фильм {name} в фильмотеке не обнаружен"
```
### метод принимает в качестве параметра имя фильма, проверяет, авторизован ли пользователь (current_user не None), проходит циклом по плейлисту (именам видео в нем), если не находит точного совпадения имени фильма в плейлисте и входного параметра, то возвращает уведомление что такой фильм не обнаружен, если же фильм найден, то проходим циклом по списку пользователей из статического параметра users, находим нужного пользователя и проверяем условие: чтобы не совпало два обстоятельства - пользователю было менее 18 лет и выбранный фильм им для просмотра имеет ограничение 18+ True. В этом случае метод возвращает сообщение, что пользователь должен покинуть страницу. Если же все нормально и совпадений для ограничения не обнаружилось, то метод вызывает внутренний вспомогательный метод _dur_video, который возвращает тайминг просмотра и уведомляет об окончании просмотра.    

### метод _dur_video
```commandline
    def _dur_video(self, time_now=0):
        while True:
            tm = mn = h = '00'
            sec = 0
            for q in range(0, 24):
                h = tm[:-len(str(q))] + str(q)
                for j in range(0, 60):
                    mn = tm[:-len(str(j))] + str(j)
                    for i in range(0, 60):
                        sc = tm[:-len(str(i))]+str(i)
                        dur = h+':'+mn+':'+sc
                        print('Идет просмотр видео. '+dur)
                        sleep(0.5)#для предотвращения времени вывода печати в консоль сократил время засыпания вдвое
                        if sec == time_now:
                            return 'Конец видео'
                        sec += 1
            return 'Конец видео'

```
### этот метод представляет тайминг в одном из привычных человеку формате: hh:mm:ss. Внутри цикла (для сброса тайминга по окончании текущего просмотра) заданы значения для часов, минут и секунд по умолчанию в строковом формате- '00'. До запуска циклов for (для секунд, минут и часов) объявляетя числовой счетчик sec = 0. Внешний цикл для часов (от 0 до 24), внутри этого цикла переменной часы присваивается при каждом проходе строковое значение, состоящее из значения по умолчанию ('00'), справа обрезанное через функцию slice() на количество символов счетчика этого цикла (q). Таким образом, через заданное время функцией sleep() оно будет изменяться (например: 00,01,02,03 и т.д. до 23). Внутри этого цикла подобный цикл for для минут, но в диапазоне от 0 до 60, и далее внутри цикла минут - иикл for для секунд. Внутри секундного цикла в переменную dur конкатенируются часы, минуты, секунды и выводятся в консоль через print(). Затем управление передаетя в фунгкцию sleep(). Необходимо акцентировать внимание, что в тестовом и учебном варианте аргумент функции sleep() имеет смысл установить в несколько раз (или даже десятков, сотен или тысяч) меньше секунды, чтобы при длинных циклах ускорить процесс разработки и отладки. Так как по условиям задания в данном варианте таймер ограничен 20 сек, то я установил аргумент sleep() в полсекунды. Необходимо пояснить роль переменной sec: дело в том, что переменная dur применяется исключительно для удобной и привычной человеку визуализации тайминга просмотра, а фактичеки сверка определенного пользователем времени просмотра ведется с переменной sec, скрытой от глаз, когда установленное пользователем в секундах время воспроизведения видео сравняется с фактическими секундами в переменной sec программа выйдет из цикла с увеломлением что кино окончено. 

# Управляющий блок кода
### Блок размещен под классами и сформирован по подблокам для тестирований отдельных заданий, описанных в ТЗ. Для удобства туда добавлены print() с пояснениями конкретных действий
```commandline
ur = UrTube()#создаем экземпляр класса UrTube
print(' \nсоздаем экз класса Video с обработкой ошибок установки параметров\n' \
      '(время просмотра файла более длительности воспроизведения и без возрастных ограничений)\n')
v1 = Video('Лучший язык программирования 2024 года', 20, 200)
print(v1)
print('\nСоздаем экз класса Video с возрастными ограничениями')
v2 = Video('Для чего девушкам парень программист?', 10, adult_mode=True)
print(v2)
print('\nДобавляем оба фильма в фильмотеку (параметр videos) методом add класса UrTube')
ur.add(v1, v2)
print(ur.videos)
print('\nрегистрируем в списке пользователей пользователя младше 18 лет\n' \
      '(параметр users класса UrTube) через метод register')
a = ur.register('vasya_pupkin', 'lolkekcheburek', 13)
print(a)
print('\nпробуем повторно зарегистрироваться')
b = ur.register('vasya_pupkin', 'lolkekcheb', 1)
print(b)
print('\nрегистрируем второго пользователя старше 18 лет')
c = ur.register('urban_pythonist', 'iScX4vIJClb9YQavjAgF', 25)
print(c)
print('\nПроверяем список пользователей')
print(ur.users)
print('\nПробуем авторизовать пользователя с несуществующим логином или ошибочным паролем')
d = ur.log_in('ghjgj', 'fsdsfd')
print(d)
print('\nавторизуем зарегистрированного пользователя с помощью метода log_in класса UrTube')
e = ur.log_in('urban_pythonist', 'iScX4vIJClb9YQavjAgF')
print(e)
print('\nвыходим из аккаунта только что авторизованного пользователя с помощью метода log_out класса UrTube')
f = ur.lod_out()
print(f)
print('\nищем фильмы в фильмотеке по строке с помощью метода get_videos класса UrTube')
g = ur.get_videos('ПРОГ')
print(g)
h = ur.get_videos('Лучш')
print(h)
print('\nхотим посмотреть фильмы из фильмотеки с помощью метода whatch_video класса UrYube (нет авторизованных пользователей)')
j = ur.watch_video('Для чего девушкам парень программист?')
print(j)
print('\nавторизуем для просмотра фильма 18+ пользователя младше 18')
k = ur.log_in('vasya_pupkin', 'lolkekcheburek')
print(k)
print('\nпытаемся воспроизвести фильм')
m = ur.watch_video('Для чего девушкам парень программист?')
print(m)
print('\nменяем запрос на фильм без возрастных ограничений и начинаем просмотр фильма')
o = ur.watch_video('Лучший язык программирования 2024 года')
print(o)
print('\nвыходим из аккаунта пользователя младше 18')
p = ur.lod_out()
print(p)
print('\nавторизуем пользователя старше 18')
t = ur.log_in('urban_pythonist', 'iScX4vIJClb9YQavjAgF')
print(t)
print('\nвводим название фильма для просмотра с ошибкой')
v = ur.watch_video('ля чего девушкам парень программист')
print(v)
print('\nисправляем ошибки в названии видео')
w = ur.watch_video('Для чего девушкам парень программист?')
print(w)
```
### Прикрепляю скрины выполнения кода в консоли
![скрин1](https://github.com/andrzejabramov/Slice/edit/master/hometasks/hometasks/homework26/image/Скан1.png)
![скрин2](https://github.com/andrzejabramov/Slice/edit/master/hometasks/hometasks/homework26/image/Скан2.png)
![скрин3](https://github.com/andrzejabramov/Slice/edit/master/hometasks/hometasks/homework26/image/Скан3.png)


## Благодарю за задание! Было очень интересно
