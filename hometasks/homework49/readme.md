## Описание работы модуля module_10_4.py "Потоки гостей в кафе"

### Домашнее задание выполнено Абрамовым Андреем

#### Импортируем необходимые библиотеки:
```commandline
from threading import Thread
import queue
from time import sleep
import random
```
- библиотека для создания потоков
- библиотека для создания очередей
- библиотека засыпания программы для визуализации работы потоков
- библиотека генерации случайного числа для засыпания программы на разный временной период, равный случайному числу

### Создаем класс, описывающий столы в кафе:
```commandline
class Table:
    def __init__(self, number, guest=None):
        self.number = number
        self.guest = guest
```
#### Этот класс имеет два атррибута:
- number (номер стола)
- guest (атрибут, указывающий, что стол либо свободен - по умолчанию, либо занят гостем - экземпляр следующего класса Guest)

### Создаем класс Guest(Thread) - дочерний класс от класса потоков Thread
```commandline
class Guest(Thread):

    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        return sleep(random.randint(3, 10))
```
Этот класс в методе инициализации имеет ссылку на родительский класс: super().__init(),
имеет атрибут name (имя гостя), а также метод run от родительского класса, через засыпание программы имитирующий период обслуживание клиентов за столами

### Создаем класс Cafe (Кафе) c атрибутом *tables, описывающий:
- в методе def guest_arrival(self, *guests) распределение гостей по столам
- статическим атрибутом queue (очередь) - помещаются прибывшие гости, которым не хвалило столов
```commandline
class Cafe:
    que = queue.Queue()
    def __init__(self, *tables):
        self.tables = tables

    def guest_arrival(self, *guests):
        for g in guests:
            for tbl in self.tables:
                if tbl.guest is None:
                    g.start()
                    tbl.guest = g
                    print(f'{g.name} сел(-а) за стол номер {tbl.number}')
                    break
            else:
                self.que.put(g)
                print(f'{g.name} в очереди')

    def discuss_guests(self):
        for guest in guests:
            if guest.is_alive():
                guest.join()
        list_tables = list(self.tables)
        while len(list_tables) > 0:
            for tbl in list_tables:
                if tbl.guest != None:
                    print(f'{tbl.guest.name} покушал(-а) и ушел(ушла).\nСтол номер {tbl.number} свободен')
                    tbl.guest = None
                    if self.que.empty() == False:
                        g_que = self.que.get()
                        cafe.guest_arrival(g_que)
                        g_que.join()
                    else:
                        list_tables.remove(tbl)
```
Создаем экз класса Queue() из импортированного модуля queue, coхраняем его в статическом атрибуте que
Инициализируем объект с еще одним атрибутом tables, принимающим неограниченное количество элементов

В методе guest_arrival(self, *guests), где атрибут - неограниченое количество экземпляров класса Guest - гости (они же потоки)
Проходим по внешнему циклу - гостей и внутреннему - столам: если стол свободен (атрибут guest принимает значение None):
стартуем поток - гость, присваиваем атрибуту стола значение потока - гостя: tbl.guest = g и выводим в консоль сообщение что такой-то гость сел за такой-то стол
Выходим из внутреннего цикла оператором break. Внешний цикл переходит к след гостю и для него находится свободный стол
И так по всем гостям, для которых получилось найти своболные столы. Для остальных гостей перемещаемся к оператору else (этот оператор принадлежит внешнему циклу for)
и оставшиеся клиенты помещаются в очередь, о чем сообщается оператором print в консоль

Метод discuss_guests отвечает за обслуживание гостей. Вначале он проверяет запущенные потоки и каждому присваивает оператор join()
Затем мы из атрибута self.tables, который является неизменяемым объектом - кортежем, создаем список.
Это необходимо для того, чтобы в последующем цикле, когда гостей в очереди не останется, реализовать удаление 
из списка столов, которые освободились и далее цикл проводить по оставшимся занятым столам
Внешний цикл while работает до тех пор, пока хотябы один стол занят (список не пустой)
Внутренний цикл по столам при завершении работы очередного потока - гостя присваивает столу атрибут tbl.guest = None
и сообщает в консоль, что очередной гость поел и ушел.
Если в очереди остались гости, то вызывается метод guest_arrival для гостя, полученного из очереди методом get
запускается поток, далее в методе discuss_guests() следует оператор join() для этого потока
Когда же очередь пуста, то освободившийся стол удаляется из списка, уменьшая размер списка и так до нуля.
Цикл завершавет работу. Программа завершается.

Прикладываю скрин консоли:
![img1.png](https://github.com/andrzejabramov/Slice/blob/master/hometasks/homework49/img1.png)
![img2.png](https://github.com/andrzejabramov/Slice/blob/master/hometasks/homework49/img2.png)




